<template>
  <view wx:if="{{ show }}" class="voice_indicator" bind:longpress="handleLongPressVoice"
    bind:touchmove="handleTouchMove" bind:touchend="handleTouchEnd" bind:touchcancel="handleTouchCancel">按住说话</view>
  <view wx:if="{{ showVoiceInput }}" class="voice-input {{isRecording ? 'recording' : ''}}">
    <view class="wave">
      <view class="wave-container" wx:if="{{ isRecording }}">
        <view class="wave-bar" wx:for="{{ waveBarsActive }}" wx:key="index"
          style="height: {{item}}%; animation-delay: {{index * 0.05}}s;"></view>
      </view>
      <view wx:else class="wave-text">
        识别中<text class="dot dot1">.</text><text class="dot dot2">.</text><text class="dot dot3">.</text>
      </view>
    </view>

    <view class="bottom-buttons" wx:if="{{ isRecording }}">
      <view class="cancel {{currentTouchArea === TouchArea.CANCEL ? 'cancel-active' : ''}}"
        style="{{ currentTouchArea === TouchArea.CANCEL ? 'background-color: #FF4040;' : '' }}">{{ currentTouchArea ===
          TouchArea.CANCEL ? '松开取消' : '取消' }}</view>
      <view class="speak">{{ currentTouchArea === TouchArea.CANCEL
        ? '按住说话' : '松开发送' }}</view>
    </view>
  </view>
</template>


<script lang="ts">
import { getErrorMessage, isPointInArea } from "@/utils/voice";
import { createComponent, PropType } from "@mpxjs/core"
const plugin = requirePlugin("WechatSI");
let recordRecoManager = plugin.getRecordRecognitionManager();
const MAX_START_RETRY = 3;
const START_RETRY_INTERVAL = 300;

enum TouchArea {
  CANCEL = 'cancel',
  SPEAK = 'speak',
  OTHER = 'other'
}

createComponent({
  properties: {
    show: {
      type: Boolean,
      value: false
    },
    language: {
      type: String as PropType<'zh_CN' | 'en_US' | 'zh_HK' | 'sichuanhua'>,
      value: 'zh_CN'
    },
    maxDuration: {
      type: Number,
      value: 10000
    },
    minDuration: {
      type: Number,
      value: 500
    },
    enableHaptic: {
      type: Boolean,
      value: true
    }
  },

  data: {
    voiceInput: "",
    waveBarsActive: [50, 80, 65, 95, 45, 85, 70, 55, 80, 60, 75, 90, 50, 80, 65],
    waveBarsSilence: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    isRecording: false,
    isCancelled: false,
    touchStartTime: 0,
    recordingTime: 0, // 录音时长（秒）
    recordingTimer: null as any, // 录音计时器
    showVoiceInput: false,
    cancelButtonRect: null as any, // 取消按钮的位置信息
    speakButtonRect: null as any, // 说话按钮的位置信息
    // 手指移动到的区域
    currentTouchArea: TouchArea.OTHER,
    TouchArea,
    // 录音结果
    recordingResult: '', // 录音识别结果
  },

  // 监听 showVoiceInput 属性变化
  watch: {
    showVoiceInput: {
      handler(show: boolean) {
        if (show) {
          this.startRecording();
          this.getButtonRects();
        } else {
          if (this.data.isRecording) {
            this.stopRecording();
          }
        }
      },
      immediate: true
    }
  },
  attached() {
    const ctx = this as any;
    ctx._isMounted = true;
    ctx._isStarting = false;
    ctx._startRetryCount = 0;
    ctx._startRetryTimer = null;
    ctx._hasEmitted = false;
  },
  detached() {
    const ctx = this as any;
    ctx._isMounted = false;
    this.clearStartRetryTimer();
    ctx._isStarting = false;
    ctx._hasEmitted = false;
    ctx._startRetryCount = 0;
    this.stopRecordingTimer();
    this.clearAllCallbacks();
    this.stopRecording();
  },

  methods: {
    /**
     * 清除所有录音管理器回调
     */
    clearAllCallbacks() {
      if (recordRecoManager) {
        recordRecoManager.onStart = null;
        recordRecoManager.onStop = null;
        recordRecoManager.onError = null;
        recordRecoManager.onRecognize = null;
      }
    },
    clearStartRetryTimer() {
      const ctx = this as any;
      if (ctx._startRetryTimer) {
        clearTimeout(ctx._startRetryTimer);
        ctx._startRetryTimer = null;
      }
    },
    scheduleStartRetry() {
      const ctx = this as any;
      ctx._startRetryCount += 1;
      this.clearStartRetryTimer();
      ctx._startRetryTimer = setTimeout(() => {
        if (!ctx._isMounted) {
          return;
        }
        // 重试时清除之前的回调并获取新实例
        this.clearAllCallbacks();
        recordRecoManager = plugin.getRecordRecognitionManager();
        this.recordHandler();
        ctx._isStarting = true;
        ctx._hasEmitted = false;
        this.resetRecordingMeta();
        this.setData({
          isRecording: true,
        });
        recordRecoManager.start({
          duration: this.data.maxDuration,
          lang: this.data.language
        });
      }, START_RETRY_INTERVAL);
    },
    resetRecordingMeta() {
      this.setData({
        recordingResult: '',
        voiceInput: '',
        touchStartTime: Date.now(),
        recordingTime: 0,
      });
    },
    /**
     * 录音管理器回调
     */
    recordHandler() {
      const ctx = this as any;

      recordRecoManager.onStart = () => {
        ctx._isStarting = false;
        ctx._startRetryCount = 0;
        this.clearStartRetryTimer();
        if (!ctx._isMounted) {
          return;
        }
        this.setData({
          isRecording: true,
          touchStartTime: Date.now(),
          recordingTime: 0,
        });
        this.startRecordingTimer();
      };

      recordRecoManager.onStop = (res: any) => {
        console.log('onStop: ', new Date().getSeconds());
        ctx._isStarting = false;
        ctx._startRetryCount = 0;
        this.clearStartRetryTimer();
        this.stopRecordingTimer();
        const result = res?.result || '';

        if (!ctx._isMounted) {
          ctx._hasEmitted = false;
          return;
        }

        this.setData({
          isRecording: false,
          recordingResult: result,
          voiceInput: result
        });

        if (ctx._hasEmitted) {
          return;
        }

        const isCancelled = this.data.currentTouchArea === TouchArea.CANCEL;
        this.emitResult(isCancelled ? '' : result, isCancelled);
      };

      recordRecoManager.onError = (res: any) => {
        console.log('onError: ', new Date().getSeconds());
        const retcode = res?.retcode;
        ctx._isStarting = false;

        if (retcode === -30011 && ctx._startRetryCount < MAX_START_RETRY) {
          this.stopRecordingTimer();
          this.scheduleStartRetry();
          return;
        }

        this.clearStartRetryTimer();
        this.stopRecordingTimer();

        if (!ctx._isMounted) {
          return;
        }

        this.setData({
          isRecording: false,
        });

        const errorMessage = getErrorMessage(retcode);

        ctx._startRetryCount = 0;

        wx.showToast({
          title: errorMessage,
          icon: 'none',
          duration: 3000
        });

        if (!ctx._hasEmitted) {
          this.emitResult('', false);
        }
      };
    },
    /**
     * 长按说话
     */
    async handleLongPressVoice() {
      // 检查麦克风权限
      const hasPermission = await this.checkRecordPermission();
      if (!hasPermission) {
        return;
      }
      const ctx = this as any;
      this.clearStartRetryTimer();
      ctx._startRetryCount = 0;
      ctx._hasEmitted = false;
      ctx._isStarting = false;
      wx.vibrateShort({
        type: "medium"
      });

      this.setData({
        showVoiceInput: true,
        currentTouchArea: TouchArea.SPEAK,
        isRecording: false
      });
    },

    /**
     * 检查并请求录音权限
     */
    async checkRecordPermission(): Promise<boolean> {
      return new Promise((resolve) => {
        wx.getSetting({
          success: (res) => {
            if (res.authSetting['scope.record'] === false) {
              // 用户已拒绝授权，引导去设置页面
              wx.showModal({
                title: '需要麦克风权限',
                content: '请在设置中开启麦克风权限，以使用语音输入功能',
                confirmText: '去设置',
                cancelText: '取消',
                success: (modalRes) => {
                  if (modalRes.confirm) {
                    wx.openSetting({
                    });
                  }
                }
              });
              resolve(false);
            } else if (res.authSetting['scope.record'] === undefined) {
              // 从未请求过权限，发起授权请求
              wx.authorize({
                scope: 'scope.record',
                success: () => {
                  wx.showToast({
                    title: '授权成功，请再次点击开始录音',
                    icon: 'success',
                    duration: 2000
                  });
                },
                fail: () => {
                  wx.showToast({
                    title: '需要麦克风权限才能使用语音输入',
                    icon: 'none',
                    duration: 2000
                  });
                }
              });
              resolve(false);
            } else {
              // 已授权
              resolve(true);
            }
          },
          fail: () => {
            wx.showToast({
              title: '获取权限状态失败',
              icon: 'none',
              duration: 2000
            });
            resolve(false);
          }
        });
      });
    },

    // 获取按钮位置信息
    getButtonRects() {
      const cancelQuery = this.createSelectorQuery();
      cancelQuery.select('.cancel').boundingClientRect();

      const speakQuery = this.createSelectorQuery();
      speakQuery.select('.speak').boundingClientRect();

      cancelQuery.exec((cancelRes: any) => {
        if (cancelRes && cancelRes[0]) {
          this.setData({
            cancelButtonRect: cancelRes[0]
          });
        }
      });
      speakQuery.exec((speakRes: any) => {
        if (speakRes && speakRes[0]) {
          this.setData({
            speakButtonRect: speakRes[0]
          });
        }
      });
    },

    /**
     * 触摸移动
     * @param e
     */
    handleTouchMove(e: any) {
      if (!this.data.showVoiceInput) return;

      const touch = e.touches[0];
      const touchX = touch.clientX;
      const touchY = touch.clientY;

      // 检查是否移动到取消按钮
      if (isPointInArea(touchX, touchY, this.data.cancelButtonRect)) {
        if (this.data.currentTouchArea === TouchArea.CANCEL) return;
        console.log("移动到取消按钮");
        wx.vibrateShort({
          type: "medium",
        });
        this.setData({
          currentTouchArea: TouchArea.CANCEL,
        });
        return;
      }

      // 检查是否移动到说话按钮
      if (isPointInArea(touchX, touchY, this.data.speakButtonRect)) {
        if (this.data.currentTouchArea === TouchArea.SPEAK) return;
        console.log("移动到说话按钮");
        wx.vibrateShort({
          type: "medium",
        });
        this.setData({
          currentTouchArea: TouchArea.SPEAK,
        });
        return;
      }

      this.setData({
        currentTouchArea: TouchArea.OTHER,
      });
    },

    /**
     * 触摸结束
     * @param e
     */
    handleTouchEnd(e: any) {
      if (this.data.currentTouchArea === TouchArea.CANCEL) {
        // 取消时立即清除所有回调，避免 onStop 触发
        this.clearAllCallbacks();
        this.emitResult('', true);
      }
      this.stopRecording();
    },

    /**
     * 触摸取消。手指触摸动作被打断，如弹窗和来电提醒
     */
    handleTouchCancel() {
      // 取消时立即清除所有回调，避免 onStop 触发
      this.clearAllCallbacks();
      this.emitResult('', true);
      this.stopRecording();
    },

    /**
     * 开始录音
     */
    startRecording() {
      const ctx = this as any;
      if (this.data.isRecording || ctx._isStarting) return;

      // 先清除之前的回调，确保使用全新的管理器实例
      this.clearAllCallbacks();

      // 获取新的管理器实例
      recordRecoManager = plugin.getRecordRecognitionManager();
      this.recordHandler();
      ctx._isStarting = true;
      ctx._startRetryCount = 0;
      ctx._hasEmitted = false;
      this.clearStartRetryTimer();
      this.resetRecordingMeta();
      this.setData({
        isRecording: true,
      });
      recordRecoManager.start({
        duration: this.data.maxDuration,
        lang: this.data.language
      });
    },

    /**
     * 停止录音
     */
    stopRecording() {
      const ctx = this as any;
      this.clearStartRetryTimer();
      ctx._isStarting = false;
      ctx._startRetryCount = 0;
      if (recordRecoManager) {
        console.log('stopRecording: ', new Date().getSeconds());
        try {
          recordRecoManager.stop();
        } catch (e) {
          console.error('stop recording error:', e);
        }
      }
      // 延迟清除回调，确保 stop 操作完成
      setTimeout(() => {
        this.clearAllCallbacks();
      }, 100);
      this.setData({
        isRecording: false,
      });
      this.stopRecordingTimer();
    },

    /**
     * 停止录音计时
     */
    stopRecordingTimer() {
      if (this.data.recordingTimer) {
        clearInterval(this.data.recordingTimer);
        this.setData({
          recordingTimer: null
        });
      }
    },

    /**
     * 开始录音计时
     */
    startRecordingTimer() {
      this.data.recordingTimer = setInterval(() => {
        const elapsed = Math.floor((Date.now() - this.data.touchStartTime) / 1000);
        this.setData({
          recordingTime: elapsed
        });
      }, 1000);
    },

    /**
     * 发送录音结果
     * @param result
     * @param isCancelled
     */
    emitResult(result: string, isCancelled: boolean) {
      const ctx = this as any;
      ctx._hasEmitted = true;
      ctx._isStarting = false;
      this.clearStartRetryTimer();
      wx.vibrateShort({
        type: "medium"
      });
      this.triggerEvent('voiceResult', {
        result,
        isCancelled: isCancelled
      });
      this.setData({
        showVoiceInput: false,
      });
    }
  },
});
</script>

<style>
.voice_indicator {
  height: 68rpx;
  background-color: #0a0a0a;
  border-radius: 24rpx;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-size: 14px;
}

.voice-input {
  display: flex;
  flex-direction: column;
  align-items: center;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  width: 100vw;
  height: 100vh;
  background: linear-gradient(to top, rgba(0, 0, 0, 0.8) 0%, transparent 100%);
  z-index: 9999;
  padding: 60rpx 0;
  box-sizing: border-box;
}

.wave {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 254rpx;
  height: 92rpx;
  background-color: #FADA39;
  border-radius: 23rpx;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0 20rpx;
  box-sizing: border-box;
  flex-direction: column;
}

.wave-container {
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  height: 40rpx;
  gap: 2rpx;
}

.wave-bar {
  background-color: #000;
  border-radius: 1rpx;
  animation: waveAnimation 1.5s ease-in-out infinite;
  min-height: 8rpx;
  width: 4rpx;
}

.wave-text {
  font-size: 14px;
  color: #000;
  text-align: center;
  line-height: 1.4;
  word-wrap: break-word;
}

.wave-text .dot {
  display: inline-block;
  animation: dotFade 1.5s infinite;
}

.wave-text .dot1 {
  animation-name: dotFade1;
}

.wave-text .dot2 {
  animation-name: dotFade2;
}

.wave-text .dot3 {
  animation-name: dotFade3;
}

@keyframes dotFade1 {

  0%,
  100% {
    opacity: 1;
  }
}

@keyframes dotFade2 {

  0%,
  33% {
    opacity: 0;
  }

  34%,
  100% {
    opacity: 1;
  }
}

@keyframes dotFade3 {

  0%,
  66% {
    opacity: 0;
  }

  67%,
  100% {
    opacity: 1;
  }
}

/* 录音时的增强动画 */
.voice-input.recording .wave-bar {
  animation: recordingWaveAnimation 0.8s ease-in-out infinite;
}

@keyframes waveAnimation {

  0%,
  100% {
    transform: scaleY(0.3);
  }

  50% {
    transform: scaleY(1);
  }
}

@keyframes recordingWaveAnimation {

  0%,
  100% {
    transform: scaleY(0.2);
  }

  25% {
    transform: scaleY(0.8);
  }

  50% {
    transform: scaleY(1.2);
  }

  75% {
    transform: scaleY(0.6);
  }
}

/* 文字显示区域 */
.text-display {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, 50%);
  width: 500rpx;
  min-height: 80rpx;
  background-color: rgba(0, 0, 0, 0.6);
  border-radius: 20rpx;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20rpx;
  box-sizing: border-box;
}

.text-content {
  color: #fff;
  font-size: 28rpx;
  text-align: center;
  line-height: 1.4;
  word-wrap: break-word;
}

/* 错误状态样式 */
.voice-input.error .text-display {
  background-color: rgba(255, 0, 0, 0.3);
  border: 2rpx solid #ff4444;
}

.voice-input.error .text-content {
  color: #ff6666;
}

.recording-time {
  color: #FADA39;
  font-size: 24rpx;
  font-weight: bold;
  margin-top: 10rpx;
  display: block;
}

.bottom-buttons {
  position: absolute;
  bottom: 60rpx;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 80rpx;
}

.cancel {
  width: 160rpx;
  height: 160rpx;
  background-color: #666;
  border-radius: 80rpx;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #fff;
  font-size: 14px;
}

.speak {
  width: 630rpx;
  height: 92rpx;
  background-color: #666;
  border-radius: 24rpx;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #fff;
  font-size: 14px;
  transition: all 0.2s ease;
  user-select: none;
}

.speak:active {
  background-color: #555;
  transform: scale(0.98);
}

.cancel {
  width: 160rpx;
  height: 160rpx;
  background-color: #666;
  border-radius: 80rpx;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #fff;
  font-size: 14px;
  transition: all 0.2s ease;
  user-select: none;
}

.cancel:active {
  background-color: #555;
  transform: scale(0.95);
}

.cancel-active {
  background-color: #FF4040 !important;
}
</style>
